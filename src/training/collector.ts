import { db } from '../database/connection.js';
import { RouterOutput } from '../ai/types.js';
import { computeQualityScore } from './scorer.js';
import {
  SavedTrainingEntry,
  TrainingContext,
  TrainingEntry,
  TrainingMetadata,
  TweetEngagement
} from './types.js';

interface TrainingDataRow {
  id: number;
  type: string;
  input: string;
  output: string;
  context: string | null;
  source: string;
  metadata: TrainingMetadata;
  quality_score: string;
  created_at: Date;
}

export class TrainingDataCollector {
  /**
   * Save any training entry. Automatically computes quality score.
   */
  async save(entry: TrainingEntry): Promise<SavedTrainingEntry> {
    const qualityScore = computeQualityScore(entry);
    const contextStr = entry.context ? JSON.stringify(entry.context) : null;
    const metadataJson = entry.metadata ?? {};

    const result = await db.query<TrainingDataRow>(
      `INSERT INTO training_data (type, input, context, output, quality_score, source, metadata)
       VALUES ($1, $2, $3, $4, $5, $6, $7)
       RETURNING id, created_at, quality_score`,
      [
        entry.type,
        entry.input,
        contextStr,
        entry.output,
        qualityScore,
        entry.source,
        JSON.stringify(metadataJson)
      ]
    );

    const row = result.rows[0];

    console.info(
      `[Collector] saved type=${entry.type} source=${entry.source} score=${qualityScore} id=${row.id}`
    );

    return {
      ...entry,
      id: row.id,
      qualityScore,
      createdAt: row.created_at
    };
  }

  /**
   * Middleware wrapper: call after router.route() to persist the interaction.
   *
   * @example
   * const result = await router.route({ prompt });
   * await collector.fromRouterOutput(prompt, result, 'whatsapp', { userRole: 'user', conversationLength: 3 });
   */
  async fromRouterOutput(
    input: string,
    routerOutput: RouterOutput,
    source: TrainingEntry['source'],
    context?: TrainingContext,
    extraMeta?: Partial<TrainingMetadata>
  ): Promise<SavedTrainingEntry> {
    return this.save({
      type: 'conversation',
      input,
      output: routerOutput.text,
      source,
      context,
      metadata: {
        provider: routerOutput.provider,
        model: routerOutput.model,
        latencyMs: routerOutput.latencyMs,
        inputTokens: routerOutput.inputTokens,
        outputTokens: routerOutput.outputTokens,
        complexity: routerOutput.complexity,
        fallbackUsed: routerOutput.fallbackUsed,
        ...extraMeta
      }
    });
  }

  /**
   * Save a tweet generated by the agent.
   */
  async saveTweet(
    content: string,
    tweetType: 'post' | 'reply' | 'quote',
    context?: TrainingContext,
    extraMeta?: Partial<TrainingMetadata>
  ): Promise<SavedTrainingEntry> {
    return this.save({
      type: 'tweet_write',
      input: `Generate a ${tweetType} tweet`,
      output: content,
      source: 'twitter',
      context,
      metadata: {
        tweetType,
        ...extraMeta
      }
    });
  }

  /**
   * Save a study session result.
   */
  async saveStudy(
    topic: string,
    findings: string,
    context?: TrainingContext
  ): Promise<SavedTrainingEntry> {
    return this.save({
      type: 'study',
      input: topic,
      output: findings,
      source: 'internal',
      context
    });
  }

  /**
   * Save a code analysis result.
   */
  async saveCodeAnalysis(
    file: string,
    analysis: string,
    context?: TrainingContext
  ): Promise<SavedTrainingEntry> {
    return this.save({
      type: 'code_analysis',
      input: file,
      output: analysis,
      source: 'internal',
      context
    });
  }

  /**
   * Update engagement data for a tweet entry and recompute quality score.
   */
  async updateTweetEngagement(id: number, engagement: TweetEngagement): Promise<void> {
    const existing = await db.query<TrainingDataRow>(
      'SELECT type, input, output, context, source, metadata FROM training_data WHERE id = $1',
      [id]
    );

    if (!existing.rows[0]) return;

    const row = existing.rows[0];
    const meta: TrainingMetadata = { ...row.metadata, tweetEngagement: engagement };
    const ctx: TrainingContext | undefined = row.context ? JSON.parse(row.context) : undefined;

    const newScore = computeQualityScore({
      type: row.type as TrainingEntry['type'],
      input: row.input,
      output: row.output,
      source: row.source as TrainingEntry['source'],
      context: ctx,
      metadata: meta
    });

    await db.query(
      'UPDATE training_data SET quality_score = $1, metadata = $2 WHERE id = $3',
      [newScore, JSON.stringify(meta), id]
    );

    console.info(`[Collector] updated engagement id=${id} newScore=${newScore}`);
  }

  /**
   * Return basic stats about collected data (useful for owner dashboards in Phase 7).
   */
  async stats(): Promise<{ total: number; byType: Record<string, number>; avgScore: number }> {
    const totals = await db.query<{ type: string; count: string; avg_score: string }>(
      `SELECT type, COUNT(*) as count, AVG(quality_score) as avg_score
       FROM training_data GROUP BY type`
    );

    const byType: Record<string, number> = {};
    let weightedSum = 0;
    let total = 0;

    for (const row of totals.rows) {
      const count = parseInt(row.count, 10);
      byType[row.type] = count;
      total += count;
      weightedSum += parseFloat(row.avg_score ?? '0') * count;
    }

    return {
      total,
      byType,
      avgScore: total > 0 ? parseFloat((weightedSum / total).toFixed(2)) : 0
    };
  }
}

export const collector = new TrainingDataCollector();
