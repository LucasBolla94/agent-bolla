import { db } from '../database/connection.js';
import { RouterOutput } from '../ai/types.js';
import { computeQualityScore } from './scorer.js';
import {
  SavedTrainingEntry,
  TrainingContext,
  TrainingEntry,
  TrainingMetadata,
  TweetEngagement
} from './types.js';

interface TrainingDataRow {
  id: number;
  type: string;
  input: string;
  output: string;
  context: string | null;
  source: string;
  metadata: TrainingMetadata;
  quality_score: string;
  created_at: Date;
}

export class TrainingDataCollector {
  /**
   * Save any training entry. Automatically computes quality score.
   */
  async save(entry: TrainingEntry): Promise<SavedTrainingEntry> {
    const qualityScore = computeQualityScore(entry);
    const contextStr = entry.context ? JSON.stringify(entry.context) : null;
    const metadataJson = entry.metadata ?? {};

    const result = await db.query<TrainingDataRow>(
      `INSERT INTO training_data (type, input, context, output, quality_score, source, metadata)
       VALUES ($1, $2, $3, $4, $5, $6, $7)
       RETURNING id, created_at, quality_score`,
      [
        entry.type,
        entry.input,
        contextStr,
        entry.output,
        qualityScore,
        entry.source,
        JSON.stringify(metadataJson)
      ]
    );

    const row = result.rows[0];

    console.info(
      `[Collector] saved type=${entry.type} source=${entry.source} score=${qualityScore} id=${row.id}`
    );

    return {
      ...entry,
      id: row.id,
      qualityScore,
      createdAt: row.created_at
    };
  }

  /**
   * Middleware wrapper: call after router.route() to persist the interaction.
   *
   * @example
   * const result = await router.route({ prompt });
   * await collector.fromRouterOutput(prompt, result, 'whatsapp', { userRole: 'user', conversationLength: 3 });
   */
  async fromRouterOutput(
    input: string,
    routerOutput: RouterOutput,
    source: TrainingEntry['source'],
    context?: TrainingContext,
    extraMeta?: Partial<TrainingMetadata>
  ): Promise<SavedTrainingEntry> {
    return this.save({
      type: 'conversation',
      input,
      output: routerOutput.text,
      source,
      context,
      metadata: {
        provider: routerOutput.provider,
        model: routerOutput.model,
        latencyMs: routerOutput.latencyMs,
        inputTokens: routerOutput.inputTokens,
        outputTokens: routerOutput.outputTokens,
        complexity: routerOutput.complexity,
        fallbackUsed: routerOutput.fallbackUsed,
        ...extraMeta
      }
    });
  }

  /**
   * Save a tweet generated by the agent.
   */
  async saveTweet(
    content: string,
    tweetType: 'post' | 'reply' | 'quote',
    context?: TrainingContext,
    extraMeta?: Partial<TrainingMetadata>
  ): Promise<SavedTrainingEntry> {
    return this.save({
      type: 'tweet_write',
      input: `Generate a ${tweetType} tweet`,
      output: content,
      source: 'twitter',
      context,
      metadata: {
        tweetType,
        ...extraMeta
      }
    });
  }

  /**
   * Save a study session result.
   */
  async saveStudy(
    topic: string,
    findings: string,
    context?: TrainingContext
  ): Promise<SavedTrainingEntry> {
    return this.save({
      type: 'study',
      input: topic,
      output: findings,
      source: 'internal',
      context
    });
  }

  /**
   * Save a code analysis result.
   */
  async saveCodeAnalysis(
    file: string,
    analysis: string,
    context?: TrainingContext
  ): Promise<SavedTrainingEntry> {
    return this.save({
      type: 'code_analysis',
      input: file,
      output: analysis,
      source: 'internal',
      context
    });
  }

  /**
   * Update engagement data for a tweet entry and recompute quality score.
   */
  async updateTweetEngagement(id: number, engagement: TweetEngagement): Promise<void> {
    const existing = await db.query<TrainingDataRow>(
      'SELECT type, input, output, context, source, metadata FROM training_data WHERE id = $1',
      [id]
    );

    if (!existing.rows[0]) return;

    const row = existing.rows[0];
    const meta: TrainingMetadata = { ...row.metadata, tweetEngagement: engagement };
    const ctx: TrainingContext | undefined = row.context ? JSON.parse(row.context) : undefined;

    const newScore = computeQualityScore({
      type: row.type as TrainingEntry['type'],
      input: row.input,
      output: row.output,
      source: row.source as TrainingEntry['source'],
      context: ctx,
      metadata: meta
    });

    await db.query(
      'UPDATE training_data SET quality_score = $1, metadata = $2 WHERE id = $3',
      [newScore, JSON.stringify(meta), id]
    );

    console.info(`[Collector] updated engagement id=${id} newScore=${newScore}`);
  }

  /**
   * Return basic stats about collected data (useful for owner dashboards in Phase 7).
   */
  async stats(): Promise<{ total: number; byType: Record<string, number>; avgScore: number }> {
    const totals = await db.query<{ type: string; count: string; avg_score: string }>(
      `SELECT type, COUNT(*) as count, AVG(quality_score) as avg_score
       FROM training_data GROUP BY type`
    );

    const byType: Record<string, number> = {};
    let weightedSum = 0;
    let total = 0;

    for (const row of totals.rows) {
      const count = parseInt(row.count, 10);
      byType[row.type] = count;
      total += count;
      weightedSum += parseFloat(row.avg_score ?? '0') * count;
    }

    return {
      total,
      byType,
      avgScore: total > 0 ? parseFloat((weightedSum / total).toFixed(2)) : 0
    };
  }

  async getTopTwitterTopics(limit = 20): Promise<Array<{ topic: string; score: number }>> {
    const result = await db.query<{ topic: string; score: string }>(
      `SELECT
         metadata->>'topic' AS topic,
         (
           COUNT(*)::numeric +
           COALESCE(SUM((metadata->'tweetEngagement'->>'likes')::numeric), 0) * 0.10 +
           COALESCE(SUM((metadata->'tweetEngagement'->>'retweets')::numeric), 0) * 0.25 +
           COALESCE(SUM((metadata->'tweetEngagement'->>'replies')::numeric), 0) * 0.20
         ) AS score
       FROM training_data
       WHERE source = 'twitter'
         AND type = 'tweet_write'
         AND metadata ? 'topic'
       GROUP BY metadata->>'topic'
       ORDER BY score DESC
       LIMIT $1`,
      [limit]
    );

    return result.rows
      .map((row) => ({
        topic: (row.topic || '').trim().toLowerCase(),
        score: Number(row.score || '0')
      }))
      .filter((row) => row.topic.length > 0 && Number.isFinite(row.score));
  }

  async statsBySourceAndType(): Promise<Array<{
    source: string;
    type: string;
    total: number;
    avgScore: number;
  }>> {
    const result = await db.query<{
      source: string;
      type: string;
      total: string;
      avg_score: string;
    }>(
      `SELECT source, type, COUNT(*)::text as total, AVG(quality_score)::text as avg_score
       FROM training_data
       GROUP BY source, type
       ORDER BY source ASC, type ASC`
    );

    return result.rows.map((row) => ({
      source: row.source,
      type: row.type,
      total: parseInt(row.total, 10),
      avgScore: parseFloat((Number(row.avg_score || '0')).toFixed(2))
    }));
  }

  async topDiscussedTopics(limit = 10): Promise<Array<{ topic: string; total: number }>> {
    const result = await db.query<{ topic: string; total: string }>(
      `WITH extracted AS (
         SELECT
           COALESCE(
             NULLIF(metadata->>'topic', ''),
             CASE
               WHEN context IS NOT NULL AND context <> '' THEN (context::jsonb ->> 'topic')
               ELSE NULL
             END
           ) AS topic
         FROM training_data
       )
       SELECT LOWER(TRIM(topic)) AS topic, COUNT(*)::text as total
       FROM extracted
       WHERE topic IS NOT NULL AND TRIM(topic) <> ''
       GROUP BY LOWER(TRIM(topic))
       ORDER BY COUNT(*) DESC
       LIMIT $1`,
      [limit]
    );

    return result.rows.map((row) => ({
      topic: row.topic,
      total: parseInt(row.total, 10)
    }));
  }

  async deleteLowQualityOlderThan(retentionDays: number, threshold: number): Promise<number> {
    const safeDays = Number.isFinite(retentionDays) && retentionDays > 0 ? Math.floor(retentionDays) : 30;
    const safeThreshold = Number.isFinite(threshold) ? threshold : 0.45;

    const result = await db.query<{ id: number }>(
      `DELETE FROM training_data
       WHERE created_at < NOW() - ($1 || ' days')::interval
         AND COALESCE(quality_score, 0) < $2
       RETURNING id`,
      [safeDays.toString(), safeThreshold]
    );

    return result.rowCount || 0;
  }
}

export const collector = new TrainingDataCollector();
